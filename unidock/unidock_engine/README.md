# UD2

Uni-Dock2 C++ engine, working together with unidock_process.

This document serves for Developers, not Users.

## Requirements
* CUDA 11.8+
* GLIB 2.31+ (Ubuntu 20.04+); GLIB 2.35+ (Ubuntu 22.04+) for unit tests [todo: re-compile catch2 for 2.31]

## Compilation
There will be a binary `ud2` under `build/bin` and the library it relies on: `build/src/libud_lib.so`.

Assure the library path  


## How to run it
The input you should prepare is a config.yaml file, definition of which can be found 
in template file `ud2/data/config_template.yaml`.

As illustrated in the yaml file, you should also prepare a json file containing the 
receptor & ligands info, which can be generated by **unidock_process**.

### Example
```shell
cd ud2/test/data/dev1
../../../build/bin/ud2 config.yaml
```

### Different Pre-defined Tasks
Several typical tasks are defined, and you can easily apply them by setting `congfig.yaml`:
```shell
...
Settings:
  task: !!str screen # screen | score | mc | free
...
```
Explaination of pre-defined tasks:

#### screen
Perform standard docking tasks, where ONE receptor and some(>0) ligands are provided. 
For each ligand, `Advanced->exhaustiveness` MC searching tasks will finally generate 
`Advanced->exhaustiveness` poses. After clustered according to `Advanced->rmsd_limit`,
the best `Advanced->num_pose` poses withing the `Advanced->energy_range` kcal/mol
will be output to the result json file, along with their energy terms.

The **energy terms** of one pose is a list of floats, namely `[Predicted Free Energy of Affinity, 
Total Score, Intra-molecular Score, Inter-molecular Score, Conformation-independent Score, 
Penalty Score]`.

#### score
Just provide score for the current pose of each providing ligand. No 
randomization/searching/optimization/clustering/filtering/refinement will be performed.
Only the given pose and its energy terms will be saved to the result json file.

#### optimize
Just optimize the input ligand pose. No randomization/searching/optimization/clustering/filtering will be performed.
The optimized pose and its energy terms will be saved to the result json file.

#### randomize
Only perform randomization to create `exhaustiveness` poses for each given ligand. It is usually used to generate
random poses. And you can also test the distribution of randomization methods with it.
No optimization/clustering/filtering/refinement will be performed.

#### mc
Only perform Monte Carlo searching to find the best poses. It is usually used to test the 
sampling ability of MC process. In this task, after randomization, the metropolis MC will 
be performed without optimization of each pose. 
Clustering/filtering will still be performed.
No refinement.

#### free
If the pre-defined tasks can't meet your need, pls use `screen` as the task type, and change
detailed settings in `Advanced` as you like, since all provided parameters will take effect for 
`screen` task.

#### benchmark [Not Loaded]
This is a convenient way to perform benchmark test to check the correctness and speed of UD2.
By given many receptor&best_ligand_pose data, UD2 will first perform "screen" task to find the
best `num_pose` poses and record their predicted affinity and RMSD from the expected best pose,
along with the total time cost.

Users could perform further analysis based on these data.

## Source Code Illustration
* **api** Provides APIs for other languages like python.
* **bin** Stores published functional binaries for users.
* **data** Stores reference files, such as the input configuration file template.
* **doc** Provides Doxygen-generated documents.
* **include** Contains third-party header files.
* **lib** Contains third-party static libraries (not modified from source) built for this project.
* **src** Contains basic source code files.
* **test** Includes unit tests and component tests.
* **set_env.sh** An easy-to-use shell script for developers to quickly set up a ready-to-use development environment.
* **scripts** [Not Loaded] Provides easy-to-use scripts for users to run standard docking processes, requiring no understanding of the coding details.

## TODO:
- [ ] Use new data structure to simplify the memory management. 


   
